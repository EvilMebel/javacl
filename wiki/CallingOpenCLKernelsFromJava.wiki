#summary How to call OpenCL Kernels from Java

= Introduction =

Let's assume you wrote the following kernel in file `com/mypackage/MyProgram.cl`:
{{{
__kernel void myKernel(__global const float* input, __global const float* output, float multFactor) {
   int i = get_global_id(0);
   output[i] = input[i] * multFactor;
}
}}}

Then you have two ways to call it from JavaCL :  a generic dynamic way, which is loosely typed, and a hard-typed precompiled way.

= Common Host Setup code =

{{{
CLContext context = ... ; // e.g. JavaCL.createBestContext()
CLQueue queue = ... ; // e.g. context.createDefaultQueue()

int dataSize = 128;
CLFloatBuffer input = context.createFloatBuffer(CLMem.Usage.Input, dataSize);
CLFloatBuffer input = context.createFloatBuffer(CLMem.Usage.Output, dataSize);
float multFactor = 0.5f;
}}}

= Generic 'Dynamic' Call =

Setting up the kernel :
{{{
String sources = ... ; // read the source file from resources / from a file
CLProgram program = context.createProgram(sources).build();
CLKernel kernel = program.createKernel("myKernel");
}}}

Calling the kernel :
{{{
CLEvent kernelCompletion;
// The same kernel can be safely used by different threads, as long as setArgs + enqueueNDRange are in a synchronized block
synchronized (kernel) {
    // setArgs will throw an exception at runtime if the types / sizes of the arguments are incorrect
    kernel.setArgs(input, output, multFactor);

   // Ask for 1-dimensional execution of length dataSize, with auto choice of local workgroup size :
    kernelCompletion = kernel.enqueueNDRange(queue, new int[]Â { dataSize }, null);
}
kernelCompletion.waitFor(); // better not to wait for it but to pass it as a dependent event to some other queuable operation (CLBuffer.read, for instance)
}}}

= Autogenerated Type-Safe Kernel Wrapper =

Setting up the JavaCL Generator Maven Plugin in the pom.xml Maven project configuration file :
{{{
<plugin>
	<groupId>com.nativelibs4java</groupId>
	<artifactId>javacl-generator</artifactId>
	<version>1.0-SNAPSHOT</version>
	<executions>
	  <execution>
		<phase>generate-sources</phase>
		<goals>
		  <goal>compile</goal>
		</goals>
	  </execution>
	</executions>
</plugin>
}}}

Setting up the kernel :
{{{
// The JavaCL Generator Maven Plugin will autogenerate a MyProgram class out of the MyProgram.cl file :
import com.mypackage.MyProgram;
...
MyProgram myProgram = new MyProgram(context);
}}}

Calling the kernel :
{{{
// This call is statically typed :
CLEvent kernelCompletion = myProgram.myKernel(queue, input, output, multFactor, new int[] { dataSize }, null);
}}}