#summary How to call OpenCL Kernels from Java

= Introduction =

Let's assume you wrote the following kernel :
{{{
__kernel void myKernel(__global const float* input, __global const float* output, float multFactor) {
   int i = get_global_id(0);
   output[i] = input[i] * multFactor;
}
}}}

Then you have two ways to call it from JavaCL :  a generic dynamic way, which is loosely typed, and a hard-typed precompiled way.

= Host Setup code =

{{{
CLContext context = ... ; // e.g. JavaCL.createBestContext()
CLQueue queue = ... ; // e.g. context.createDefaultQueue()

int dataSize = 128;
CLFloatBuffer input = context.createFloatBuffer(CLMem.Usage.Input, dataSize);
CLFloatBuffer input = context.createFloatBuffer(CLMem.Usage.Output, dataSize);
float multFactor = 0.5f;
}}}

= Generic 'Dynamic' Call =

Setting up the kernel :
{{{
String sources = ... ;
CLProgram program = context.createProgram(sources).build();
CLKernel kernel = program.createKernel("myKernel");
}}}

Calling the kernel :
{{{
CLEvent kernelCompletion;
// The same kernel can be safely used by different threads, as long as setArgs + enqueueNDRange are in a synchronized block
synchronized (kernel) {
    // setArgs will throw an exception at runtime if the types / sizes of the arguments are incorrect
    kernel.setArgs(input, output, multFactor);

   // Ask for 1-dimensional execution of length dataSize, with auto choice of local workgroup size :
    kernelCompletion = kernel.enqueueNDRange(queue, new int[]Â { dataSize }, null);
}
kernelCompletion.waitFor(); // better not to wait for it but to pass it as a dependent event to some other queuable operation (CLBuffer.read, for instance)
}}}