#summary How to start with JavaCL

<wiki:toc max_depth="3" />

This quick tutorial will get you through setting up a JavaCL project.

= Setup a JavaCL Maven project =

The preferred way of creating a JavaCL project is using Maven.
  * [http://maven.apache.org/ Install Maven]
  * Create a `JavaCLTutorial` directory 
  * Create the following `pom.xml` file in that directory :
  {{{
<project xmlns="http://maven.apache.org/POM/4.0.0"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 <modelVersion>4.0.0</modelVersion>
  <groupId>com.nativelibs4java</groupId>
  <artifactId>javacl-tutorial</artifactId>
  <name>JavaCL Tutorial</name>
  <version>1.0-SNAPSHOT</version>
  <packaging>jar</packaging>
  
  <repositories>
    <repository>
      <id>nativelibs4java</id>
      <name>nativelibs4java Maven2 Repository</name>
      <url>http://nativelibs4java.sourceforge.net/maven</url>
    </repository>
  </repositories>
  
  <dependencies>
	<dependency>
	  <groupId>com.nativelibs4java</groupId>
	  <artifactId>javacl</artifactId>
	  <version>1.0.0-RC1</version>
	</dependency>
  </dependencies>

  <build>
  	<plugins>
		<plugin>
			<groupId>com.nativelibs4java</groupId>
			<artifactId>javacl-generator</artifactId>
			<version>1.0.0-RC1</version>
			<executions>
			  <execution>
				<phase>generate-sources</phase>
				<goals>
				  <goal>compile</goal>
				</goals>
			  </execution>
			</executions>
		</plugin>
	</plugins>
  </build>
</project>
}}}
  * Create the following file hierarchy (see below for the .java and .cl files) :
  {{{
JavaCLPlugin
|__ pom.xml
|__ src/
     |__ test 
     |__ main/
          |__ java/
          |    |__ tutorial/
          |         |__ JavaCLTutorial.java
          |__ opencl/
               |__ tutorial/
                    |__ TutorialKernels.cl
}}}
  On an Unix system, this can be achieved with the following commands :
  {{{
mkdir -p JavaCLPlugin/src/main/java/tutorial/
touch JavaCLPlugin/src/main/java/tutorial/JavaCLTutorial.java

mkdir -p JavaCLPlugin/src/main/opencl/tutorial/
touch JavaCLPlugin/src/main/opencl/tutorial/TutorialKernels.cl
}}}

= A very simple OpenCL addition program =

This is the OpenCL equivalent of the traditional Hello-world example : we're just going to perform parallel piece-wise additions on two float vectors, storing the results on a third float vector.

It contains two parts :
  * an OpenCL source code that will be compiled at run-time and run on an OpenCL device (CPU or GPU)
  * a Java host program that sets up the JavaCL context, reads and compiles the OpenCL source code and calls it with appropriately initialized arguments.

== Writing the OpenCL kernel ==

Edit `JavaCLPlugin/src/main/opencl/tutorial/TutorialKernels.cl` as follows :
{{{
kernel void add_floats(global const float* a, global const float* b, global float* out, int n) 
{
    int i = get_global_id(0);
    if (i >= n)
        return;

    out[i] = a[i] + b[i];
}
}}}

== Writing the JavaCL host program ==

Edit `JavaCLPlugin/src/main/java/tutorial/JavaCLTutorial.java` as follows :
{{{
package tutorial;

import com.nativelibs4java.opencl.*;
import com.nativelibs4java.opencl.util.*;
import com.nativelibs4java.util.*;
import org.bridj.Pointer;
import static org.bridj.Pointer.*;
import static java.lang.Math.*;

public class JavaCLTutorial {
    public static void main(String[] args) {
        CLContext context = JavaCL.createBestContext();
        CLQueue queue = context.createDefaultQueue();

        int n = 1024;
        Pointer<Float>
            aPtr = allocateFloats(n),
            bPtr = allocateFloats(n);

        for (int i = 0; i < n; i++) {
            aPtr.set(i, (float)cos(i));
            bPtr.set(i, (float)sin(i));
        }

        // Create OpenCL input buffers (using the native memory pointers aPtr and bPtr) :
        CLBuffer<Float> 
            a = context.createFloatBuffer(Usage.Input, aPtr),
            b = context.createFloatBuffer(Usage.Input, bPtr);

        // Create an OpenCL output buffer :
        CLBuffer<Float> out = context.createFloatBuffer(Usage.Output, n);

        // Read the program sources and compile them :
        String src = IOUtils.readText(JavaCLTutorial.class.getResource("TutorialKernels.cl"));
        CLProgram program = context.createProgram(src);

        // Get and call the kernel :
        CLKernel addFloatsKernel = program.createKernel("add_floats");
        addFloatsKernel.setArgs(a, b, out, n);
        CLEvent addEvt = addFloatsKernel.enqueueNDRange(queue, new int[] { n });
        
        Pointer<Float> outPtr = out.read(queue, addEvt); // blocks until add_floats finished

        // Print the first 10 output values :
        for (int i = 0; i < 10 && i < n; i++)
            System.out.println("out[" + i + "] = " + outPtr.get(i));
        
    }
}
}}}

= Refining that simple code... =

== Use the JavaCL program wrapper generator to make the code even simpler ! ==

Saw that "javacl-generator" config in the `pom.xml` file ?

It's a tool that parses any `.cl` file present in `src/main/opencl` and creates a wrapper class that only accepts the correct argument types and numbers, instead of the all-forgiving [http://nativelibs4java.sourceforge.net/javacl/api/stable/com/nativelibs4java/opencl/CLKernel.html#setArgs(java.lang.Object...) CLKernel.setArgs(Object...)] that might make your program crash at runtime if you used an incorrect argument type (or missed an argument).

You actually need nothing more than the `pom.xml` to use the generator, so you can modify the host code as follows :
{{{
        /* 
        This code is no longer needed :
        // Read the program sources and compile them :
        String src = IOUtils.readText(JavaCLTutorial.class.getResource("TutorialKernels.cl"));
        CLProgram program = context.createProgram(src);
        
        // Get and call the kernel :
        CLKernel addFloatsKernel = program.createKernel("add_floats");
        addFloatsKernel.setArgs(a, b, out, n);
        CLEvent evt = addFloatsKernel.enqueueNDRange(queue, new int[] { n });
        */

        // Instantiate the auto-generated program wrapper and call the kernel :
        TutorialKernels kernels = new TutorialKernels(context);
        CLEvent addEvt = kernels.add_floats(queue, new int[] { n }, a, b, out, n);

        Pointer<Float> outPtr = out.read(queue, addEvt); // blocks until add_floats finished

}}}

Simple, isn't it ?

The program wrappers will be regenerated automatically at each compilation, so they'll keep in sync with your OpenCL kernels !

== Perform (and chain) more calculations in OpenCL ==

In the code above, we've initialized the `a` and `b` buffers with pointers to memory that we've filled by hand in Java... Why not fill it straight in OpenCL (i.e. on the GPU, if the context uses a GPU device) ?

Add the following kernel to `JavaCLPlugin/src/main/opencl/tutorial/TutorialKernels.cl` :
{{{
kernel void fill_in_values(global float* a, global float* b, int n) 
{
    int i = get_global_id(0);
    if (i >= n)
        return;

    a[i] = cos((float)i);
    b[i] = sin((float)i);
}
}}}

And change your Java code as follows :
{{{
        // Create OpenCL input and output buffers :
        CLBuffer<Float> 
            a = context.createFloatBuffer(Usage.InputOutput, n), // a and b are now read AND written to
            b = context.createFloatBuffer(Usage.InputOutput, n),
            out = context.createFloatBuffer(Usage.Output, n);

        // Instantiate the auto-generated program wrapper and chain calls to the two kernel :
        TutorialKernels kernels = new TutorialKernels(context);

        CLEvent fillEvt = kernels.fill_in_values(queue, new int[] { n }, a, b, n);
        CLEvent addEvt = kernels.add_floats(queue, new int[] { n }, a, b, out, n, fillEvt);

        Pointer<Float> outPtr = out.read(queue, addEvt); // blocks until add_floats finished
}}}

See how we've chained dependent operations through events (operations are executed asynchronously from the Java program) : 
  * the add_floats kernel execution must wait for the fill_in_values execution to finish
  * the out.read operation must wait for the add_floats execution to finish.