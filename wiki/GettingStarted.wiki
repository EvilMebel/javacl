#summary How to start with JavaCL

<wiki:toc max_depth="3" />

This quick tutorial will get you through setting up a JavaCL project.

= Setup a JavaCL Maven project =

== Open/create the tutorial project with Netbeans 7.0 ==

You can either create a plain Maven project by hand and modify its `pom.xml` as below, or use the fully automated way that uses a Maven archetype :
  * Create a new project
  [http://javacl.googlecode.com/svn/wiki/images/NetbeansArchetype-NewProject.png]
  * Choose `Maven / Project from Archetype` :
  [http://javacl.googlecode.com/svn/wiki/images/NetbeansArchetype-ChooseProject.png]
  * In the `Maven Archetype` screen, click on `Add`, fill-in the details then click on `Ok` :
    * Group Id = `com.nativelibs4java`
    * Archetype Id = `javacl-simple-tutorial`
    * Version = `1.0.0-RC1`
    * Repository = `http://nativelibs4java.sourceforge.net/maven`
  [http://javacl.googlecode.com/svn/wiki/images/NetbeansArchetype-AchetypeDetails.png]
  * Select the custom archetype you've just created and click on `Next`, then `Finish` :
  [http://javacl.googlecode.com/svn/wiki/images/NetbeansArchetype-CustomArchetype.png]

== Command-line setup ==

First, please make sure you've properly installed [http://maven.apache.org/ Maven].

Then simply type the following commands in a shell (replace myGroupId and myArtifactId by your own group and artifact ids) :
{{{
mvn archetype:generate -DarchetypeGroupId=com.nativelibs4java -DarchetypeArtifactId=javacl-simple-tutorial -DarchetypeVersion=1.0.0-RC1 -DremoteRepositories=http://nativelibs4java.sourceforge.net/maven
}}}

This will generate a directory with the following layout :
  {{{
myArtifactId
|__ pom.xml
|__ src/
     |__ test 
     |__ main/
          |__ java/
          |    |__ tutorial/
          |         |__ JavaCLTutorial1.java
          |         |__ JavaCLTutorial2.java
          |         |__ JavaCLTutorial3.java
          |__ opencl/
               |__ tutorial/
                    |__ TutorialKernels.cl
}}}

The three versions of the JavaCLTutorial class correspond to the progression of this tutorial, as you'll see below.

== Creating the project by hand ==

  * Create a `JavaCLTutorial` directory 
  * Create the following `pom.xml` file in that directory :
  {{{
<project xmlns="http://maven.apache.org/POM/4.0.0"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 <modelVersion>4.0.0</modelVersion>
  <groupId>com.nativelibs4java</groupId>
  <artifactId>javacl-tutorial</artifactId>
  <name>JavaCL Tutorial</name>
  <version>1.0-SNAPSHOT</version>
  <packaging>jar</packaging>
  
  <repositories>
    <repository>
      <id>nativelibs4java</id>
      <name>nativelibs4java Maven2 Repository</name>
      <url>http://nativelibs4java.sourceforge.net/maven</url>
    </repository>
  </repositories>
  
  <dependencies>
	<dependency>
	  <groupId>com.nativelibs4java</groupId>
	  <artifactId>javacl</artifactId>
	  <version>1.0.0-RC1</version>
	</dependency>
  </dependencies>

  <build>
  	<plugins>
			<plugin>
					<groupId>com.nativelibs4java</groupId>
					<artifactId>javacl-generator</artifactId>
					<version>1.0.0-RC1</version>
					<executions>
					  <execution>
							<phase>generate-sources</phase>
							<goals>
							  <goal>compile</goal>
							</goals>
					  </execution>
					</executions>
			</plugin>
			
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>2.3.2</version>
				<configuration>
					<source>1.5</source>
					<target>1.5</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>
	</plugins>
  </build>
</project>
}}}
  * Create the following file hierarchy (see below for the .java and .cl files) :
  {{{
JavaCLPlugin
|__ pom.xml
|__ src/
     |__ test 
     |__ main/
          |__ java/
          |    |__ tutorial/
          |         |__ JavaCLTutorial.java
          |__ opencl/
               |__ tutorial/
                    |__ TutorialKernels.cl
}}}
  On an Unix system, this can be achieved with the following commands :
  {{{
mkdir -p JavaCLTutorial/src/main/java/tutorial/
touch JavaCLTutorial/src/main/java/tutorial/JavaCLTutorial.java

mkdir -p JavaCLTutorial/src/main/opencl/tutorial/
touch JavaCLTutorial/src/main/opencl/tutorial/TutorialKernels.cl
}}}

= A very simple OpenCL addition program =

This is the OpenCL equivalent of the traditional Hello-world example : we're just going to perform parallel piece-wise additions on two float vectors, storing the results on a third float vector.

It contains two parts :
  * an OpenCL source code that will be compiled at run-time and run on an OpenCL device (CPU or GPU)
  * a Java host program that sets up the JavaCL context, reads and compiles the OpenCL source code and calls it with appropriately initialized arguments.

== Writing the OpenCL kernel ==

Edit `JavaCLPlugin/src/main/opencl/tutorial/TutorialKernels.cl` as follows :
{{{
__kernel void add_floats(__global const float* a, __global const float* b, __global float* out, int n) 
{
    int i = get_global_id(0);
    if (i >= n)
        return;

    out[i] = a[i] + b[i];
}
}}}

== Writing the JavaCL host program ==

Edit `JavaCLPlugin/src/main/java/tutorial/JavaCLTutorial.java` as follows :
{{{
package tutorial;

import com.nativelibs4java.opencl.*;
import com.nativelibs4java.opencl.util.*;
import com.nativelibs4java.util.*;
import org.bridj.Pointer;
import static org.bridj.Pointer.*;
import static java.lang.Math.*;

public class JavaCLTutorial {
    public static void main(String[] args) {
        CLContext context = JavaCL.createBestContext();
        CLQueue queue = context.createDefaultQueue();

        int n = 1024;
        Pointer<Float>
            aPtr = allocateFloats(n),
            bPtr = allocateFloats(n);

        for (int i = 0; i < n; i++) {
            aPtr.set(i, (float)cos(i));
            bPtr.set(i, (float)sin(i));
        }

        // Create OpenCL input buffers (using the native memory pointers aPtr and bPtr) :
        CLBuffer<Float> 
            a = context.createFloatBuffer(Usage.Input, aPtr),
            b = context.createFloatBuffer(Usage.Input, bPtr);

        // Create an OpenCL output buffer :
        CLBuffer<Float> out = context.createFloatBuffer(Usage.Output, n);

        // Read the program sources and compile them :
        String src = IOUtils.readText(JavaCLTutorial.class.getResource("TutorialKernels.cl"));
        CLProgram program = context.createProgram(src);

        // Get and call the kernel :
        CLKernel addFloatsKernel = program.createKernel("add_floats");
        addFloatsKernel.setArgs(a, b, out, n);
        CLEvent addEvt = addFloatsKernel.enqueueNDRange(queue, new int[] { n });
        
        Pointer<Float> outPtr = out.read(queue, addEvt); // blocks until add_floats finished

        // Print the first 10 output values :
        for (int i = 0; i < 10 && i < n; i++)
            System.out.println("out[" + i + "] = " + outPtr.get(i));
        
    }
}
}}}

== Running ==

Type this in the shell in the folder `JavaCLTutorial` :
{{{
mvn compile exec:java -Dexec.mainClass=tutorial.JavaCLTutorial
}}}

The end of the output will look like this (please allow some time the first time Maven runs : it will download *many* files, but won't do it again ;-)) :
{{{
out[0] = 1.0
out[1] = 1.3817732
out[2] = 0.49315056
out[3] = -0.8488725
out[4] = -1.4104462
out[5] = -0.6752621
out[6] = 0.6807548
out[7] = 1.4108889
out[8] = 0.84385824
out[9] = -0.49901175
}}}

= Refining that simple code... =

== Use the JavaCL program wrapper generator to make the code even simpler ! ==

Saw that "javacl-generator" config in the `pom.xml` file ?

It's a tool that parses any `.cl` file present in `src/main/opencl` and creates a wrapper class that only accepts the correct argument types and numbers, instead of the all-forgiving [http://nativelibs4java.sourceforge.net/javacl/api/stable/com/nativelibs4java/opencl/CLKernel.html#setArgs(java.lang.Object...) CLKernel.setArgs(Object...)] that might make your program crash at runtime if you used an incorrect argument type (or missed an argument).

You actually need nothing more than the `pom.xml` to use the generator, so you can modify the host code as follows :
{{{
        /* 
        This code is no longer needed :
        // Read the program sources and compile them :
        String src = IOUtils.readText(JavaCLTutorial.class.getResource("TutorialKernels.cl"));
        CLProgram program = context.createProgram(src);
        
        // Get and call the kernel :
        CLKernel addFloatsKernel = program.createKernel("add_floats");
        addFloatsKernel.setArgs(a, b, out, n);
        CLEvent evt = addFloatsKernel.enqueueNDRange(queue, new int[] { n });
        */

        // Instantiate the auto-generated program wrapper and call the kernel :
        TutorialKernels kernels = new TutorialKernels(context);
        CLEvent addEvt = kernels.add_floats(queue, a, b, out, n, new int[] { n }, null);

        Pointer<Float> outPtr = out.read(queue, addEvt); // blocks until add_floats finished

}}}

Simple, isn't it ?

The program wrappers will be regenerated automatically at each compilation, so they'll keep in sync with your OpenCL kernels !

== Perform (and chain) more calculations in OpenCL ==

In the code above, we've initialized the `a` and `b` buffers with pointers to memory that we've filled by hand in Java... Why not fill it straight in OpenCL (i.e. on the GPU, if the context uses a GPU device) ?

Add the following kernel to `JavaCLPlugin/src/main/opencl/tutorial/TutorialKernels.cl` :
{{{
kernel void fill_in_values(global float* a, global float* b, int n) 
{
    int i = get_global_id(0);
    if (i >= n)
        return;

    a[i] = cos((float)i);
    b[i] = sin((float)i);
}
}}}

And change your Java code as follows :
{{{
        // Create OpenCL input and output buffers :
        CLBuffer<Float> 
            a = context.createFloatBuffer(Usage.InputOutput, n), // a and b are now read AND written to
            b = context.createFloatBuffer(Usage.InputOutput, n),
            out = context.createFloatBuffer(Usage.Output, n);

        // Instantiate the auto-generated program wrapper and chain calls to the two kernel :
        TutorialKernels kernels = new TutorialKernels(context);

        CLEvent fillEvt = kernels.fill_in_values(queue, a, b, n, new int[] { n }, null);
        CLEvent addEvt = kernels.add_floats(queue, a, b, out, n, new int[] { n }, null, fillEvt);

        Pointer<Float> outPtr = out.read(queue, addEvt); // blocks until add_floats finished
}}}

See how we've chained dependent operations through events (operations are executed asynchronously from the Java program) : 
  * the add_floats kernel execution must wait for the fill_in_values execution to finish
  * the out.read operation must wait for the add_floats execution to finish.